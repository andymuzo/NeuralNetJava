package co.inharmonic.colours.control;

import co.inharmonic.colours.control.TrainingData.brightness;
import co.inharmonic.colours.control.TrainingData.colour;
import co.inharmonic.colours.control.TrainingData.saturation;
import co.inharmonic.colours.net.NeuralNet;

public class ColourNet {
	int hiddenNeurons;
	double trainingRate;
	int trainingCycles;
	double minRandomWeight;
	double maxRandomWeight;
	NeuralNet net;
	// Training data; input X and output y.
	// * For each input there should be an expected output value
	// * The amount of inputs should be the same as the above int "inputs"
	// * the last input is always 1.0
	double[][] trainingInputs;
	double[][] trainingOutputs;
	String[] outputNames;
	TrainingData trainingData;
	
	/**
	 * main constructor for setting up the colour net.
	 * The variables for training the net are here, should perhaps be a part of the TrainingData class
	 */
	public ColourNet() {
		// The setup
		hiddenNeurons = 20;
		// The rate at which the weight updates each training pass
		trainingRate = 1.0;
		// The number of times the backpropagation algorithm is used
		trainingCycles = 60000;
		// The spread of initial random weights
		minRandomWeight = -0.5;
		maxRandomWeight = 0.5;

		net = new NeuralNet(hiddenNeurons, trainingRate,
				trainingCycles, minRandomWeight, maxRandomWeight);

		setTrainingData();

		net.trainNet();
		
		runTestValues();
	}

	/**
	 * creates the training data and adds it to the trainingData object
	 */
	private void setTrainingData() {
		// Training data; input X and output y.
		// * For each input there should be an expected output value
		// * The amount of inputs should be the same as the above int "inputs"
		// * the last input is always 1.0
		trainingData = new TrainingData(4, 15, 225.0, 1.0);
		
		trainingData.addTrainingData(225.0, 0.0, 0.0, colour.blue, brightness.medium, saturation.high);
		
		net.setTrainingData(trainingData);
	}
	
	/**
	 * call this after training to run values through the net
	 */
	private void runTestValues() {
		double[][] inputData = new double[][] {
				{132.0, 160.0, 70.0, 255.0},
				{246.0, 255.0, 217.0, 255.0},
				{102.0, 18.0, 186.0, 255.0},
				{164.0, 100.0, 227.0, 255.0},
				{103.0, 166.0, 166.0, 255.0},
				{13.0, 144.0, 168.0, 255.0}};
		double[][] outputData = net.runData(inputData);
		
		outputResults(inputData, outputData);
	}
	
	/**
	 * Prints the inputs and outputs of the net in human-readable form
	 * only outputs results for one item at a time currently
	 * @param inputData
	 * @param outputData
	 */
	private void outputResultsOld(double[][] inputData, double[][] outputData) {
		net.printMatrix("Input values:", inputData);
		net.printMatrixInts("Output for X after training (out of 100:",
				outputData);
		for (int i = 0; i < inputData.length; i++) {
			
			// first for colours
			String introText = "RGB values: " + ((int) inputData[i][0]) + ", "
					+ ((int) inputData[i][1]) + ", " + ((int) inputData[i][2])
					+ ": ";
			int firstPositionColour = 0;
			int secondPositionColour = 0;
			
			for (int j = 0; j < TrainingData.colour.values().length; j++) {
				if (outputData[i][j] > outputData[i][firstPositionColour]) {
					firstPositionColour = j;
				}
			}
			for (int j = 0; j < TrainingData.colour.values().length; j++) {
				if (outputData[i][j] > outputData[i][secondPositionColour]
						&& j != firstPositionColour) {
					secondPositionColour = j;
				}
			}
			
			// now brightness
			int firstPositionBright = 0;
			int secondPositionBright = 0;
			int startBright = TrainingData.colour.values().length;
			int endBright = TrainingData.colour.values().length + TrainingData.brightness.values().length;
			
			for (int j = startBright; j < endBright; j++) {
				if (outputData[i][j] > outputData[i][firstPositionBright]) {
					firstPositionBright = j;
				}
			}
			for (int j = startBright; j < endBright; j++) {
				if (outputData[i][j] > outputData[i][secondPositionBright]
						&& j != firstPositionBright) {
					secondPositionBright = j;
				}
			}
			
			// now saturation
			int firstPositionSat = 0;
			int secondPositionSat = 0;
			int startSat = endBright;
			int endSat = endBright + TrainingData.saturation.values().length;
			
			for (int j = startBright; j < endBright; j++) {
				if (outputData[i][j] > outputData[i][firstPositionBright]) {
					firstPositionBright = j;
				}
			}
			for (int j = startBright; j < endBright; j++) {
				if (outputData[i][j] > outputData[i][secondPositionBright]
						&& j != firstPositionBright) {
					secondPositionBright = j;
				}
			}
			
			
			String resultsText = introText + outputNames[firstPositionColour] + " "
					+ ((int) (outputData[i][firstPositionColour] * 100.0))
					+ " percent, " + outputNames[secondPositionColour] + " "
					+ ((int) (outputData[i][secondPositionColour] * 100.0))
					+ " percent";

			System.out.println(resultsText);
		}
	}
		
		/**
		 * Prints the inputs and outputs of the net in human-readable form
		 * only outputs results for one item at a time currently
		 * @param inputData
		 * @param outputData
		 */
		private void outputResults(double[][] inputData, double[][] outputData) {
			net.printMatrix("Input values:", inputData);
			net.printMatrixInts("Output for X (out of 100):", outputData);
			// get the first and second place for each output line
			for (int i = 0; i < inputData.length; i++) {
				String introText = "RGB values: " + ((int) inputData[i][0]) + ", "
						+ ((int) inputData[i][1]) + ", " + ((int) inputData[i][2])
						+ ": ";
				int firstPosition = 0;
				int secondPosition = 0;
				
				// need to do this separately for the 3 output parameters
				for (int j = 0; j < outputData[0].length; j++) {
					if (outputData[i][j] > outputData[i][firstPosition]) {
						firstPosition = j;
					}
				}
				for (int j = 0; j < outputData[0].length; j++) {
					if (outputData[i][j] > outputData[i][secondPosition]
							&& j != firstPosition) {
						secondPosition = j;
					}
				}
				
				
				
				
				String resultsText = introText + outputNames[firstPosition] + " "
						+ ((int) (outputData[i][firstPosition] * 100.0))
						+ " percent, " + outputNames[secondPosition] + " "
						+ ((int) (outputData[i][secondPosition] * 100.0))
						+ " percent";

				System.out.println(resultsText);
			}
	}
}
